'use strict';

const internals = {};


exports.errors = {
    root: 'value',
    key: '"{{#label}}" ',
    wrapArrays: true,

    'any.unknown': 'is not allowed',
    'any.invalid': 'contains an invalid value',
    'any.empty': 'is not allowed to be empty',
    'any.required': 'is required',
    'any.allowOnly': 'must be one of {{#valids}}',
    'any.default': 'threw an error when running default method',
    'any.failover': 'threw an error when running failover method',

    'alternatives.base': 'does not match any of the allowed types',
    'alternatives.types': 'must be one of {{#types}}',
    'alternatives.match': 'does not match any of the allowed types',

    'array.base': 'must be an array',
    'array.includes': 'does not match any of the allowed types',
    'array.includesRequiredUnknowns': 'does not contain {{#unknownMisses}} required value(s)',
    'array.includesRequiredKnowns': 'does not contain {{#knownMisses}}',
    'array.includesRequiredBoth': 'does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)',
    'array.excludes': 'contains an excluded value',
    'array.hasKnown': 'does not contain at least one required match for type "{#patternLabel}"',
    'array.hasUnknown': 'does not contain at least one required match',
    'array.min': 'must contain at least {{#limit}} items',
    'array.max': 'must contain less than or equal to {{#limit}} items',
    'array.length': 'must contain {{#limit}} items',
    'array.orderedLength': 'must contain at most {{#limit}} items',
    'array.ref': 'references "{{#ref}}" which is not a positive integer',
    'array.sort': 'must be sorted in {#order} order by {{#by}}',
    'array.sort.mismatching': 'cannot be sorted due to mismatching types',
    'array.sort.unsupported': 'cannot be sorted due to unsupported type {#type}',
    'array.sparse': 'must not be a sparse array item',
    'array.unique': 'contains a duplicate value',

    'boolean.base': 'must be a boolean',

    'binary.base': 'must be a buffer or a string',
    'binary.min': 'must be at least {{#limit}} bytes',
    'binary.max': 'must be less than or equal to {{#limit}} bytes',
    'binary.length': 'must be {{#limit}} bytes',
    'binary.ref': 'references "{{#ref}}" which is not a positive integer',

    'date.base': 'must be a number of milliseconds or valid date string',
    'date.strict': 'must be a valid date',
    'date.min': 'must be larger than or equal to "{{#limit}}"',
    'date.max': 'must be less than or equal to "{{#limit}}"',
    'date.less': 'must be less than "{{#limit}}"',
    'date.greater': 'must be greater than "{{#limit}}"',
    'date.isoDate': 'must be a valid ISO 8601 date',
    'date.timestamp.javascript': 'must be a valid timestamp or number of milliseconds',
    'date.timestamp.unix': 'must be a valid timestamp or number of seconds',
    'date.ref': 'references "{{#ref}}" which is not a date',

    'function.base': 'must be a Function',
    'function.arity': 'must have an arity of {{#n}}',
    'function.class': 'must be a class',
    'function.maxArity': 'must have an arity lesser or equal to {{#n}}',
    'function.minArity': 'must have an arity greater or equal to {{#n}}',

    'lazy.base': '!!schema error: lazy schema must be set',
    'lazy.schema': '!!schema error: lazy schema function must return a schema',

    'object.base': 'must be an object',
    'object.allowUnknown': 'is not allowed',
    'object.and': 'contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}',
    'object.assert': 'is invalid because "{{#ref}}" failed to {{#message}}',
    'object.length': 'must have {{#limit}} children',
    'object.max': 'must have less than or equal to {{#limit}} children',
    'object.min': 'must have at least {{#limit}} children',
    'object.missing': 'must contain at least one of {{#peersWithLabels}}',
    'object.nand': '!!"{{#mainWithLabel}}" must not exist simultaneously with {{#peersWithLabels}}',
    'object.oxor': 'contains a conflict between optional exclusive peers {{#peersWithLabels}}',
    'object.ref': 'references "{{#ref}}" which is not a positive integer',
    'object.refType': 'must be a Joi reference',
    'object.rename.multiple': 'cannot rename "{{#from}}" because multiple renames are disabled and another key was already renamed to "{{#to}}"',
    'object.rename.override': 'cannot rename "{{#from}}" because override is disabled and target "{{#to}}" exists',
    'object.schema': 'must be a Joi schema of {{#type}} type',
    'object.type': 'must be an instance of "{{#type}}"',
    'object.with': '!!"{{#mainWithLabel}}" missing required peer "{{#peerWithLabel}}"',
    'object.without': '!!"{{#mainWithLabel}}" conflict with forbidden peer "{{#peerWithLabel}}"',
    'object.xor': 'contains a conflict between exclusive peers {{#peersWithLabels}}',

    'number.base': 'must be a number',
    'number.unsafe': 'must be a safe number',
    'number.min': 'must be larger than or equal to {{#limit}}',
    'number.max': 'must be less than or equal to {{#limit}}',
    'number.less': 'must be less than {{#limit}}',
    'number.greater': 'must be greater than {{#limit}}',
    'number.integer': 'must be an integer',
    'number.negative': 'must be a negative number',
    'number.positive': 'must be a positive number',
    'number.precision': 'must have no more than {{#limit}} decimal places',
    'number.ref': 'references "{{#ref}}" which is not a number',
    'number.multiple': 'must be a multiple of {{#multiple}}',
    'number.port': 'must be a valid port',

    'string.base': 'must be a string',
    'string.min': 'length must be at least {{#limit}} characters long',
    'string.max': 'length must be less than or equal to {{#limit}} characters long',
    'string.length': 'length must be {{#limit}} characters long',
    'string.alphanum': 'must only contain alpha-numeric characters',
    'string.token': 'must only contain alpha-numeric and underscore characters',
    'string.regex.base': 'with value "{.}" fails to match the required pattern: {{#pattern}}',
    'string.regex.name': 'with value "{.}" fails to match the {{#name}} pattern',
    'string.regex.invert.base': 'with value "{.}" matches the inverted pattern: {{#pattern}}',
    'string.regex.invert.name': 'with value "{.}" matches the inverted {{#name}} pattern',
    'string.domain': 'must contain a valid domain name',
    'string.email': 'must be a valid email',
    'string.uri': 'must be a valid uri',
    'string.uriRelativeOnly': 'must be a valid relative uri',
    'string.uriCustomScheme': 'must be a valid uri with a scheme matching the {{#scheme}} pattern',
    'string.isoDate': 'must be a valid ISO 8601 date',
    'string.isoDuration': 'must be a valid ISO 8601 duration',
    'string.guid': 'must be a valid GUID',
    'string.hex': 'must only contain hexadecimal characters',
    'string.hexAlign': 'hex decoded representation must be byte aligned',
    'string.base64': 'must be a valid base64 string',
    'string.dataUri': 'must be a valid dataUri string',
    'string.hostname': 'must be a valid hostname',
    'string.normalize': 'must be unicode normalized in the {{#form}} form',
    'string.lowercase': 'must only contain lowercase characters',
    'string.uppercase': 'must only contain uppercase characters',
    'string.trim': 'must not have leading or trailing whitespace',
    'string.creditCard': 'must be a credit card',
    'string.ref': 'references "{{#ref}}" which is not a number',
    'string.ip': 'must be a valid ip address with a {{#cidr}} CIDR',
    'string.ipVersion': 'must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR',

    'symbol.base': 'must be a symbol',
    'symbol.map': 'must be one of {{#map}}'
};
